<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D跑酷游戏</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(to bottom, #1a2a6c, #b21f1f, #fdbb2d);
        }
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
        }
        #score {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 100;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 10px 20px;
            border-radius: 20px;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 36px;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            display: none;
            z-index: 100;
            backdrop-filter: blur(5px);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.9));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }
        #startScreen h1 {
            font-size: 60px;
            text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #e60073, 0 0 40px #e60073;
            margin-bottom: 30px;
            animation: glow 1.5s ease-in-out infinite alternate;
        }
        @keyframes glow {
            from {
                text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #e60073, 0 0 40px #e60073;
            }
            to {
                text-shadow: 0 0 20px #fff, 0 0 30px #ff4da6, 0 0 40px #ff4da6, 0 0 50px #ff4da6;
            }
        }
        #startScreen p {
            font-size: 22px;
            margin-bottom: 40px;
            max-width: 80%;
            text-align: center;
            line-height: 1.6;
        }
        button {
            background: linear-gradient(to right, #4CAF50, #45a049);
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 18px;
            margin: 10px;
            cursor: pointer;
            border-radius: 30px;
            box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            font-weight: bold;
        }
        button:hover {
            background: linear-gradient(to right, #45a049, #2e7d32);
            transform: translateY(-3px);
            box-shadow: 0 12px 20px 0 rgba(0,0,0,0.3);
        }
        button:active {
            transform: translateY(1px);
        }
        .controls-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 10px 0 30px;
        }
        .key {
            display: inline-block;
            background-color: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 8px;
            padding: 8px 12px;
            margin: 0 5px;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="score">分数: 0</div>
        <div id="gameOver">
            <h2>游戏结束!</h2>
            <p id="finalScore">最终分数: 0</p>
            <button id="restartBtn">重新开始</button>
        </div>
        <div id="startScreen">
            <h1>3D跑酷游戏</h1>
            <p>避开障碍物，收集硬币，看看你能跑多远！</p>
            <div class="controls-icon">
                <span class="key">←</span>
                <span class="key">→</span> 
                <span>移动</span>
                &nbsp;&nbsp;&nbsp;
                <span class="key">空格</span> 
                <span>跳跃</span>
                &nbsp;&nbsp;&nbsp;
                <span class="key">↓</span> 
                <span>下蹲</span>
            </div>
            <button id="startBtn">开始游戏</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
    <script>
        // 游戏变量
        let scene, camera, renderer, player, ground;
        let obstacles = [];
        let clouds = [], mountains = [], stars = [];
        let lanes = [-2, 0, 2]; // 左，中，右三条跑道
        let currentLane = 1; // 默认在中间跑道
        let jumping = false;
        let doubleJumping = false; // 二段跳状态
        let canJump = true; // 是否可以跳跃
        let crouching = false; // 下蹲状态
        let speed = 0.3; // 增加初始速度
        let score = 0;
        let gameRunning = false;
        let clock = new THREE.Clock();
        let lastObstacleTime = 0; // 上次生成障碍物的时间
        let obstacleMinDistance = 50; // 适中的障碍物最小间距
        
        // 游戏元素
        const scoreElement = document.getElementById('score');
        const gameOverElement = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');
        const restartBtn = document.getElementById('restartBtn');
        const startBtn = document.getElementById('startBtn');
        const startScreen = document.getElementById('startScreen');
        
        // 初始化游戏
        function init() {
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // 天蓝色背景
            
            // 创建相机 - 调整位置和角度，避免人物档视线
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 4, 8); // 位置更高更远
            camera.lookAt(0, 0, -20);
            
            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            // 添加光源
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 0);
            scene.add(directionalLight);
            
            // 创建地面
            createGround();
            
            // 创建玩家
            createPlayer();
            
            // 创建背景
            createBackground();
            
            // 窗口调整大小事件
            window.addEventListener('resize', onWindowResize);
            
            // 键盘控制
            document.addEventListener('keydown', onKeyDown);
            
            // 添加触摸控制
            addTouchControls();
        }
        
        // 创建地面
        function createGround() {
            // 创建主地面
            const groundGeometry = new THREE.BoxGeometry(10, 0.5, 1000);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x808080,
                roughness: 0.8,
                metalness: 0.2
            });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.position.y = -0.25;
            ground.position.z = -500;
            
            // 添加地面纹理线条
            const linesCount = 50;
            const lineSpacing = 20;
            
            for (let i = 0; i < linesCount; i++) {
                const lineGeometry = new THREE.BoxGeometry(8, 0.05, 0.5);
                const lineMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.position.y = 0.01;
                line.position.z = -i * lineSpacing;
                ground.add(line);
            }
            
            // 添加左右两侧边界
            const borderMaterial = new THREE.MeshStandardMaterial({ color: 0xff4444 });
            
            const leftBorder = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 1, 1000),
                borderMaterial
            );
            leftBorder.position.set(-5, 0.25, -500);
            
            const rightBorder = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 1, 1000),
                borderMaterial
            );
            rightBorder.position.set(5, 0.25, -500);
            
            scene.add(ground);
            scene.add(leftBorder);
            scene.add(rightBorder);
        }
        
        // 创建背景环境
        function createBackground() {
            // 创建云朵
            clouds = [];
            for (let i = 0; i < 20; i++) {
                createCloud(-Math.random() * 500);
            }
            
            // 创建远处的山脉
            mountains = [];
            const mountainCount = 15;
            const mountainGeometry = new THREE.ConeGeometry(20, 30, 4);
            const mountainMaterial = new THREE.MeshStandardMaterial({ color: 0x4CAF50 });
            
            for (let i = 0; i < mountainCount; i++) {
                const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
                // 修改山脉位置，确保它们在跑道的远处和两侧
                const side = Math.random() > 0.5 ? 1 : -1; // 随机选择左右侧
                const distance = 25 + Math.random() * 90; // 与跑道的距离
                const x = side * distance;
                const z = Math.random() * -300 - 50;
                // 增加y坐标的负值，确保山脉不会穿过跑道
                mountain.position.set(x, -20, z);
                mountain.rotation.y = Math.random() * Math.PI * 2;
                scene.add(mountain);
                mountains.push(mountain);
            }
            
            // 创建星星（夜空效果）
            stars = [];
            const starCount = 200;
            const starGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const starMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            for (let i = 0; i < starCount; i++) {
                const star = new THREE.Mesh(starGeometry, starMaterial);
                const x = Math.random() * 400 - 200;
                const y = Math.random() * 200 + 50;
                const z = Math.random() * -300 - 50;
                star.position.set(x, y, z);
                scene.add(star);
                stars.push(star);
            }
        }
        
        // 创建云朵
        function createCloud(zPosition) {
            const cloudGroup = new THREE.Group();
            const cloudMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const sphereGeometry1 = new THREE.SphereGeometry(5, 8, 8);
            const sphereGeometry2 = new THREE.SphereGeometry(4, 8, 8);
            const sphereGeometry3 = new THREE.SphereGeometry(4.5, 8, 8);
            
            const sphere1 = new THREE.Mesh(sphereGeometry1, cloudMaterial);
            const sphere2 = new THREE.Mesh(sphereGeometry2, cloudMaterial);
            const sphere3 = new THREE.Mesh(sphereGeometry3, cloudMaterial);
            
            sphere2.position.set(4, 1, 0);
            sphere3.position.set(-4, 1, 0);
            
            cloudGroup.add(sphere1);
            cloudGroup.add(sphere2);
            cloudGroup.add(sphere3);
            
            const x = Math.random() * 200 - 100;
            const y = Math.random() * 50 + 50;
            cloudGroup.position.set(x, y, zPosition);
            
            scene.add(cloudGroup);
            clouds.push(cloudGroup);
            
            return cloudGroup;
        }
        
        // 创建玩家
        function createPlayer() {
            // 创建玩家身体
            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x3498db });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.6;
            
            // 创建玩家头部
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xecf0f1 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.3;
            head.position.z = 0;
            
            // 创建腿部
            const legGeometry = new THREE.BoxGeometry(0.25, 0.5, 0.25);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x2980b9 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.2, -0.15, 0);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.2, -0.15, 0);
            
            // 创建一个组将所有部分结合在一起
            player = new THREE.Group();
            player.add(body);
            player.add(head);
            player.add(leftLeg);
            player.add(rightLeg);
            
            // 保存原始高度，用于下蹲恢复
            player.userData = {
                bodyHeight: 1.2,
                headPosY: 1.3,
                normalHeight: 0.8
            };
            
            // 玩家出现时的特效
            player.position.y = -2; // 开始时在地面以下
            player.scale.set(0.1, 0.1, 0.1); // 从小尺寸开始
            
            scene.add(player);
            
            // 玩家出现时的动画
            const startAnimation = {
                position: -2,
                scale: 0.1
            };
            
            const animate = function() {
                if (startAnimation.position < 0.8) {
                    startAnimation.position += 0.15;
                    player.position.y = startAnimation.position;
                }
                
                if (startAnimation.scale < 1) {
                    startAnimation.scale += 0.05;
                    player.scale.set(startAnimation.scale, startAnimation.scale, startAnimation.scale);
                }
                
                if (startAnimation.position < 0.8 || startAnimation.scale < 1) {
                    requestAnimationFrame(animate);
                }
            };
            
            animate();
        }
        
        // 创建障碍物
        function createObstacle() {
            // 检查是否有足够的距离生成新障碍物
            const currentTime = Date.now();
            if (currentTime - lastObstacleTime < obstacleMinDistance) {
                return; // 间隔太短，不生成新障碍物
            }
            
            // 优化: 限制场景中的最大障碍物数量
            if (obstacles.length > 15) {
                return; // 如果场景中障碍物已经太多，暂不生成新的
            }
            
            // 新增: 根据当前分数随机决定是否生成金币路径而不是单个障碍物
            const shouldCreateCoinPath = Math.random() < 0.2 + Math.min(score / 50000, 0.3); // 最大概率控制在50%
            
            if (shouldCreateCoinPath) {
                createCoinPath();
                return;
            }
            
            // 随机选择障碍物类型，但避免生成太复杂的障碍物
            let obstacleType = Math.floor(Math.random() * 6); // 增加到6种障碍物类型
            
            // 优化: 根据分数调整障碍物类型的分布，初始阶段更多简单障碍物
            if (score < 500) {
                obstacleType = Math.min(obstacleType, 2); // 限制为更简单的障碍物类型
            }
            
            // 避免连续生成相同类型的障碍物
            if (obstacles.length > 0 && obstacles[obstacles.length - 1].userData && 
                obstacles[obstacles.length - 1].userData.type === getObstacleTypeByIndex(obstacleType)) {
                obstacleType = (obstacleType + 1 + Math.floor(Math.random() * 3)) % 6; // 选择不同类型
            }
            
            // 检查玩家当前跑道，避免在玩家正前方生成障碍物
            let lanes = [-2, 0, 2];
            let safeLaneIndex = currentLane; // 玩家当前跑道
            let geometry, material, obstacle;
            
            // 高级障碍物不应该连续出现在相同跑道
            const lastHighObstacles = obstacles.filter(obs => 
                obs.userData && (obs.userData.type === 'high' || obs.userData.type === 'ceiling') && 
                obs.position.z < -50 && obs.position.z > -150);
            
            // 获取已存在障碍物的跑道分布情况
            const occupiedLanes = obstacles
                .filter(obs => obs.position.z < -80 && obs.position.z > -120)
                .map(obs => Math.round((obs.position.x + 2) / 2));
            
            // 根据障碍物类型设置不同的配置
            switch(obstacleType) {
                case 0: // 单个矮障碍物 - 岩石风格
                    let laneIndex;
                    
                    // 避免在玩家正前方生成障碍物
                    do {
                        laneIndex = Math.floor(Math.random() * 3);
                    } while (laneIndex === safeLaneIndex && Math.random() < 0.7); // 70%概率避开玩家当前跑道
                    
                    // 检查所选跑道是否已有障碍物
                    if (occupiedLanes.includes(laneIndex)) {
                        // 如果该跑道已有障碍物，尝试选择其他跑道
                        const availableLanes = [0, 1, 2].filter(l => !occupiedLanes.includes(l));
                        if (availableLanes.length > 0) {
                            laneIndex = availableLanes[Math.floor(Math.random() * availableLanes.length)];
                        }
                    }
                    
                    geometry = new THREE.DodecahedronGeometry(0.5, 0); // 使用多面体代替立方体
                    
                    // 创建石头材质
                    material = new THREE.MeshStandardMaterial({ 
                        color: 0x808080,
                        roughness: 0.9,
                        metalness: 0.1,
                        flatShading: true
                    });
                    
                    obstacle = new THREE.Mesh(geometry, material);
                    obstacle.position.x = lanes[laneIndex];
                    obstacle.position.y = 0.4;
                    obstacle.position.z = -100;
                    obstacle.rotation.y = Math.random() * Math.PI; // 随机旋转
                    obstacle.rotation.x = Math.random() * Math.PI / 4; // 轻微倾斜
                    obstacle.userData = { 
                        type: 'low',
                        rotationSpeed: (Math.random() - 0.5) * 0.02 // 添加随机旋转速度
                    };
                    scene.add(obstacle);
                    obstacles.push(obstacle);
                    
                    // 添加小石子作为装饰
                    for (let i = 0; i < 3; i++) {
                        const smallRock = new THREE.Mesh(
                            new THREE.DodecahedronGeometry(0.15, 0),
                            material
                        );
                        smallRock.position.set(
                            obstacle.position.x + (Math.random() - 0.5) * 0.8,
                            0.15,
                            obstacle.position.z + (Math.random() - 0.5) * 0.8
                        );
                        smallRock.rotation.set(
                            Math.random() * Math.PI,
                            Math.random() * Math.PI,
                            Math.random() * Math.PI
                        );
                        scene.add(smallRock);
                        obstacles.push(smallRock);
                        smallRock.userData = { type: 'decoration' }; // 标记为装饰物，不会造成碰撞
                    }
                    break;
                    
                case 1: // 单个高障碍物 - 水晶柱
                    let laneIndex2;
                    
                    // 检查最近的高障碍物所在跑道
                    if (lastHighObstacles.length > 0) {
                        const lastHighLanes = lastHighObstacles.map(obs => 
                            Math.round((obs.position.x + 2) / 2)); // 将x坐标转换为跑道索引
                        
                        // 避免在相同跑道上连续生成高障碍物
                        do {
                            laneIndex2 = Math.floor(Math.random() * 3);
                        } while (lastHighLanes.includes(laneIndex2));
                    } else {
                        // 避开玩家当前跑道
                        do {
                            laneIndex2 = Math.floor(Math.random() * 3);
                        } while (laneIndex2 === safeLaneIndex && Math.random() < 0.6); // 60%概率避开玩家当前跑道
                    }
                    
                    // 创建水晶体
                    geometry = new THREE.ConeGeometry(0.5, 2, 6);
                    
                    // 创建水晶材质 - 半透明带发光效果
                    material = new THREE.MeshStandardMaterial({
                        color: 0x4ecdc4,
                        roughness: 0.2,
                        metalness: 0.8,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    obstacle = new THREE.Mesh(geometry, material);
                    obstacle.position.x = lanes[laneIndex2];
                    obstacle.position.y = 1;
                    obstacle.position.z = -100;
                    obstacle.userData = { 
                        type: 'high',
                        originalColor: 0x4ecdc4,
                        pulseTime: 0
                    };
                    
                    // 添加发光效果
                    const crystalLight = new THREE.PointLight(0x4ecdc4, 1, 3);
                    crystalLight.position.set(0, 1, 0);
                    obstacle.add(crystalLight);
                    
                    scene.add(obstacle);
                    obstacles.push(obstacle);
                    break;
                    
                case 2: // 双障碍物 - 篱笆/栅栏效果
                    // 确保栅栏至少保留一条跑道让玩家通过
                    // 优先保留玩家当前跑道，但也有一定概率切换跑道增加难度
                    let skipLane;
                    if (Math.random() < 0.7) { // 70%概率保持玩家当前跑道可通行
                        skipLane = safeLaneIndex;
                    } else {
                        // 30%概率随机选择一条跑道留空，增加难度
                        skipLane = Math.floor(Math.random() * 3);
                    }
                    
                    // 创建一个组来容纳栅栏的各个部分
                    const fenceGroup = new THREE.Group();
                    fenceGroup.position.z = -100;
                    fenceGroup.userData = { type: 'fence' };
                    
                    for (let i = 0; i < 3; i++) {
                        if (i !== skipLane) {
                            // 创建栅栏柱子
                            const postGeometry = new THREE.BoxGeometry(0.15, 1.5, 0.15);
                            const postMaterial = new THREE.MeshStandardMaterial({ 
                                color: 0x8B4513,
                                roughness: 0.8,
                                metalness: 0.1
                            });
                            
                            // 创建两个柱子
                            const post1 = new THREE.Mesh(postGeometry, postMaterial);
                            post1.position.set(lanes[i] - 0.3, 0.75, 0);
                            
                            const post2 = new THREE.Mesh(postGeometry, postMaterial);
                            post2.position.set(lanes[i] + 0.3, 0.75, 0);
                            
                            // 创建横杆
                            const railGeometry = new THREE.BoxGeometry(0.8, 0.12, 0.1);
                            const railMaterial = new THREE.MeshStandardMaterial({ 
                                color: 0xA0522D,
                                roughness: 0.8,
                                metalness: 0.1
                            });
                            
                            // 添加多个横杆
                            const rail1 = new THREE.Mesh(railGeometry, railMaterial);
                            rail1.position.set(lanes[i], 0.4, 0);
                            
                            const rail2 = new THREE.Mesh(railGeometry, railMaterial);
                            rail2.position.set(lanes[i], 0.7, 0);
                            
                            const rail3 = new THREE.Mesh(railGeometry, railMaterial);
                            rail3.position.set(lanes[i], 1.0, 0);
                            
                            // 添加到组
                            fenceGroup.add(post1);
                            fenceGroup.add(post2);
                            fenceGroup.add(rail1);
                            fenceGroup.add(rail2);
                            fenceGroup.add(rail3);
                            
                            // 记录组内的元素，用于碰撞检测
                            fenceGroup.userData.height = 1.5;
                            fenceGroup.userData.lane = lanes[i];
                            fenceGroup.userData.skipLane = skipLane; // 记录空缺的跑道
                        }
                    }
                    
                    scene.add(fenceGroup);
                    obstacles.push(fenceGroup);
                    break;
                    
                case 3: // 交错障碍物 - 旋转的能量球
                    // 交错障碍物的处理 - 确保不会所有跑道同时出现障碍物
                    const energyGroup = new THREE.Group();
                    energyGroup.position.z = -100;
                    energyGroup.userData = { 
                        type: 'energy',
                        rotationSpeed: 0.02
                    };
                    
                    // 确保能量球的位置交错排列，让玩家有路可走
                    // 例如，如果第一个在左跑道，第二个应在中或右跑道
                    const usedLanes = new Set();
                    const spacing = 5; // 能量球之间的间距
                    
                    for (let i = 0; i < 3; i++) {
                        // 选择一个尚未使用的跑道
                        let energyLane;
                        do {
                            energyLane = Math.floor(Math.random() * 3);
                        } while (
                            // 第一个球避免放在玩家当前跑道
                            (i === 0 && energyLane === safeLaneIndex && Math.random() < 0.7) ||
                            // 确保同一z位置没有多个球
                            usedLanes.has(energyLane)
                        );
                        
                        usedLanes.add(energyLane);
                        
                        // 创建能量球
                        const sphereGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                        const sphereMaterial = new THREE.MeshStandardMaterial({
                            color: 0x9933ff,
                            emissive: 0x6600cc,
                            emissiveIntensity: 0.5,
                            transparent: true,
                            opacity: 0.8
                        });
                        
                        const energySphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                        energySphere.position.set(lanes[energyLane], 1, -(i * spacing));
                        
                        // 添加发光效果
                        const sphereLight = new THREE.PointLight(0x9933ff, 1, 2);
                        sphereLight.position.set(0, 0, 0);
                        energySphere.add(sphereLight);
                        
                        // 添加围绕能量球旋转的粒子环
                        const ringGeometry = new THREE.RingGeometry(0.6, 0.7, 32);
                        const ringMaterial = new THREE.MeshBasicMaterial({
                            color: 0xff00ff,
                            side: THREE.DoubleSide,
                            transparent: true,
                            opacity: 0.6
                        });
                        
                        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                        ring.rotation.x = Math.PI / 2;
                        energySphere.add(ring);
                        
                        // 添加第二个环，垂直于第一个
                        const ring2 = new THREE.Mesh(ringGeometry, ringMaterial);
                        energySphere.add(ring2);
                        
                        // 自定义数据，用于动画
                        energySphere.userData = {
                            originalY: 1,
                            floatOffset: Math.random() * Math.PI * 2, // 随机浮动起始点
                            ringRotation: Math.random() * 0.1 // 随机环旋转速度
                        };
                        
                        energyGroup.add(energySphere);
                    }
                    
                    scene.add(energyGroup);
                    obstacles.push(energyGroup);
                    break;
                    
                case 4: // 硬币奖励 - 更漂亮的金币
                    // 硬币奖励应该在玩家更容易到达的位置
                    let laneIndex4;
                    
                    // 有75%的概率将金币放在玩家当前跑道上
                    if (Math.random() < 0.75) {
                        laneIndex4 = safeLaneIndex;
                    } else {
                        // 25%概率随机选择一个跑道
                        laneIndex4 = Math.floor(Math.random() * 3);
                    }
                    
                    // 创建硬币群组
                    const coinGroup = new THREE.Group();
                    coinGroup.position.z = -100;
                    coinGroup.position.x = lanes[laneIndex4];
                    // 金币高度有变化，但确保玩家能通过跳跃收集
                    coinGroup.position.y = Math.min(2, 0.5 + Math.random() * 2); // 限制最大高度
                    coinGroup.userData = { type: 'coin' };
                    
                    // 主硬币
                    geometry = new THREE.CylinderGeometry(0.4, 0.4, 0.05, 32);
                    
                    // 创建金色材质
                    const goldMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xFFD700, 
                        metalness: 1,
                        roughness: 0.3,
                        emissive: 0xFFD700,
                        emissiveIntensity: 0.2
                    });
                    
                    obstacle = new THREE.Mesh(geometry, goldMaterial);
                    obstacle.rotation.x = Math.PI / 2; // 硬币平放
                    
                    // 添加硬币边缘的装饰纹理
                    const edgeGeometry = new THREE.TorusGeometry(0.4, 0.05, 8, 32);
                    const edge = new THREE.Mesh(edgeGeometry, goldMaterial);
                    edge.rotation.x = Math.PI / 2;
                    
                    // 添加硬币正面图案
                    const starGeometry = new THREE.CircleGeometry(0.25, 5);
                    const starMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xffd700,
                        metalness: 1,
                        roughness: 0.1,
                        emissive: 0xFFD700,
                        emissiveIntensity: 0.4
                    });
                    
                    const star = new THREE.Mesh(starGeometry, starMaterial);
                    star.position.z = 0.03;
                    star.rotation.z = Math.PI / 5;
                    
                    obstacle.add(edge);
                    obstacle.add(star);
                    
                    // 添加金币发光效果
                    const coinLight = new THREE.PointLight(0xFFD700, 0.8, 2);
                    coinLight.position.set(0, 0, 0);
                    obstacle.add(coinLight);
                    
                    coinGroup.add(obstacle);
                    coinGroup.userData.rotationSpeed = 0.03;
                    
                    scene.add(coinGroup);
                    obstacles.push(coinGroup);
                    break;
                    
                case 5: // 低空障碍物 - 激光栅栏
                    // 低空激光栅栏的处理 - 要求玩家下蹲
                    let laneIndex5;
                    
                    // 检查最近的低空障碍物所在跑道
                    if (lastHighObstacles.length > 0) {
                        const lastLaserLanes = lastHighObstacles
                            .filter(obs => obs.userData.type === 'ceiling')
                            .map(obs => Math.round((obs.position.x + 2) / 2));
                        
                        // 避免在相同跑道上连续生成低空障碍物
                        do {
                            laneIndex5 = Math.floor(Math.random() * 3);
                        } while (lastLaserLanes.includes(laneIndex5));
                    } else {
                        // 考虑玩家当前位置
                        do {
                            laneIndex5 = Math.floor(Math.random() * 3);
                        } while (laneIndex5 === safeLaneIndex && Math.random() < 0.5); // 50%概率避开玩家当前跑道
                    }
                    
                    // 创建激光组
                    const laserGroup = new THREE.Group();
                    laserGroup.position.z = -100;
                    laserGroup.userData = { 
                        type: 'ceiling',
                        pulseTime: 0,
                        laneIndex: laneIndex5 // 添加跑道索引标记
                    };
                    
                    // 创建激光支柱
                    const pillarGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.1, 8);
                    const pillarMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x333333,
                        roughness: 0.3,
                        metalness: 0.8
                    });
                    
                    const leftPillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                    leftPillar.position.set(lanes[laneIndex5] - 1.4, 0.55, 0);
                    
                    const rightPillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                    rightPillar.position.set(lanes[laneIndex5] + 1.4, 0.55, 0);
                    
                    // 创建发光的激光横杆
                    const laserGeometry = new THREE.BoxGeometry(3, 0.05, 0.05);
                    const laserMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xff0000,
                        emissive: 0xff0000,
                        emissiveIntensity: 1,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    // 修改激光宽度，使其更接近单个跑道宽度
                    obstacle = new THREE.Mesh(new THREE.BoxGeometry(2, 0.05, 0.05), laserMaterial);
                    obstacle.position.set(lanes[laneIndex5], 1.2, 0);
                    
                    // 添加发光效果
                    const laserLight = new THREE.PointLight(0xff0000, 0.5, 3);
                    laserLight.position.set(0, 0, 0);
                    obstacle.add(laserLight);
                    
                    // 添加激光的垂直"扫描"效果
                    const scanGeometry = new THREE.PlaneGeometry(3, 1);
                    const scanMaterial = new THREE.MeshBasicMaterial({
                        color: 0xff0000,
                        transparent: true,
                        opacity: 0.2,
                        side: THREE.DoubleSide
                    });
                    
                    const scanEffect = new THREE.Mesh(scanGeometry, scanMaterial);
                    scanEffect.position.set(0, -0.5, 0);
                    scanEffect.rotation.x = Math.PI / 2;
                    obstacle.add(scanEffect);
                    
                    // 添加警示灯到柱子顶部
                    const warningLightGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const warningLightMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xff0000,
                        emissive: 0xff0000
                    });
                    
                    const leftLight = new THREE.Mesh(warningLightGeometry, warningLightMaterial);
                    leftLight.position.y = 0.6;
                    leftPillar.add(leftLight);
                    
                    const rightLight = new THREE.Mesh(warningLightGeometry, warningLightMaterial);
                    rightLight.position.y = 0.6;
                    rightPillar.add(rightLight);
                    
                    laserGroup.add(leftPillar);
                    laserGroup.add(rightPillar);
                    laserGroup.add(obstacle);
                    
                    scene.add(laserGroup);
                    obstacles.push(laserGroup);
                    break;
            }
            
            // 记录障碍物生成时间
            lastObstacleTime = currentTime;
            
            // 随着分数增加，减少障碍物间距，但不低于最小值
            obstacleMinDistance = Math.max(30, 50 - (score / 1500));
            
            // 在游戏开始阶段就生成一些容易收集的金币，提升体验
            if (score < 200 && Math.random() < 0.4) {
                createInitialCoins(Math.floor(Math.random() * 3));
                return;
            }
        }
        
        // 新增: 创建金币路径函数优化
        function createCoinPath() {
            // 金币路径类型
            const pathType = Math.floor(Math.random() * 6); // 增加路径类型数量
            const laneIndex = Math.floor(Math.random() * 3); // 起始跑道
            
            // 优化: 检查是否有障碍物在目标跑道
            let isLaneFree = true;
            const minDistance = 15; // 最小安全距离
            
            for (let i = 0; i < obstacles.length; i++) {
                if (obstacles[i].position.z < -100 && obstacles[i].position.z > -200) {
                    if (Math.abs(obstacles[i].position.x - lanes[laneIndex]) < 1.0) {
                        isLaneFree = false;
                        break;
                    }
                }
            }
            
            if (!isLaneFree) {
                // 如果目标跑道有障碍物，选择另一条跑道
                const newLaneIndex = (laneIndex + 1 + Math.floor(Math.random() * 2)) % 3;
                return createCoinPath();
            }
            
            // 创建金币共同材质
            const goldMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700, 
                metalness: 1,
                roughness: 0.3,
                emissive: 0xFFD700,
                emissiveIntensity: 0.2
            });
            
            // 地面高度，金币默认放在地面上
            const groundHeight = 0.5;
            
            switch(pathType) {
                case 0: // 直线路径 - 地面上的金币
                    const coinCount = 8 + Math.floor(Math.random() * 5);
                    for (let i = 0; i < coinCount; i++) {
                        createPathCoin(lanes[laneIndex], groundHeight, -100 - (i * 5), goldMaterial);
                    }
                    
                    // 在路径末尾放置障碍物提示下一个动作
                    if (Math.random() > 0.5) {
                        // 放置高障碍物，暗示需要跳跃
                        const geometry = new THREE.ConeGeometry(0.5, 2, 6);
                        const material = new THREE.MeshStandardMaterial({
                            color: 0x4ecdc4,
                            roughness: 0.2,
                            metalness: 0.8,
                            transparent: true,
                            opacity: 0.7
                        });
                        
                        const obstacle = new THREE.Mesh(geometry, material);
                        obstacle.position.x = lanes[laneIndex];
                        obstacle.position.y = 1;
                        obstacle.position.z = -100 - (coinCount * 5) - 5;
                        obstacle.userData = { 
                            type: 'high',
                            originalColor: 0x4ecdc4,
                            pulseTime: 0
                        };
                        
                        const crystalLight = new THREE.PointLight(0x4ecdc4, 1, 3);
                        crystalLight.position.set(0, 1, 0);
                        obstacle.add(crystalLight);
                        
                    scene.add(obstacle);
                    obstacles.push(obstacle);
                    }
                    break;
                    
                case 1: // 跳跃引导路径 - 阶梯状金币设计
                    // 在开始处放置金币
                    for (let i = 0; i < 3; i++) {
                        createPathCoin(lanes[laneIndex], groundHeight, -100 - (i * 5), goldMaterial);
                    }
                    
                    // 添加跳跃指示物
                    const jumpMarker = new THREE.Mesh(
                        new THREE.ConeGeometry(0.2, 0.5, 4),
                        new THREE.MeshBasicMaterial({ color: 0xff4444 })
                    );
                    jumpMarker.position.set(lanes[laneIndex], groundHeight, -100 - 15);
                    jumpMarker.rotation.x = Math.PI;
                    scene.add(jumpMarker);
                    obstacles.push(jumpMarker);
                    jumpMarker.userData = { type: 'decoration' };
                    
                    // 创建一个矮墙作为跳跃平台
                    const platform = new THREE.Group();
                    platform.position.z = -100 - 25;
                    platform.position.x = lanes[laneIndex];
                    platform.userData = { type: 'low' };
                    
                    const platformBase = new THREE.Mesh(
                        new THREE.BoxGeometry(1.2, 1.0, 6),
                        new THREE.MeshStandardMaterial({ color: 0x808080 })
                    );
                    platformBase.position.y = 0.5;
                    platform.add(platformBase);
                    
                    scene.add(platform);
                    obstacles.push(platform);
                    
                    // 在平台上方添加金币
                    for (let i = 0; i < 4; i++) {
                        createPathCoin(lanes[laneIndex], 1.6, -100 - 25 + (i - 2) * 1.5, goldMaterial);
                    }
                    
                    // 在平台后添加下阶金币，指引下一次跳跃
                    for (let i = 0; i < 3; i++) {
                        createPathCoin(lanes[laneIndex], groundHeight, -100 - 35 - (i * 5), goldMaterial);
                    }
                    break;
                    
                case 2: // 之字形路径 - 地面上引导横向移动
                    let currentLane = laneIndex;
                    const zigzagCoinCount = 15;
                    
                    for (let i = 0; i < zigzagCoinCount; i++) {
                        if (i > 0 && i % 3 === 0) {
                            // 每三个金币改变一次跑道
                            currentLane = (currentLane + 1) % 3;
                            
                            // 在转弯处添加箭头指示物
                            const arrowIndicator = new THREE.Mesh(
                                new THREE.ConeGeometry(0.2, 0.4, 3),
                                new THREE.MeshBasicMaterial({ color: 0xffff00 })
                            );
                            arrowIndicator.position.set(
                                (lanes[currentLane] + lanes[(currentLane-1+3)%3])/2, 
                                groundHeight + 0.3, 
                                -100 - (i * 5) + 2.5
                            );
                            arrowIndicator.rotation.z = currentLane > (currentLane-1+3)%3 ? Math.PI/2 : -Math.PI/2;
                            scene.add(arrowIndicator);
                            obstacles.push(arrowIndicator);
                            arrowIndicator.userData = { type: 'decoration' };
                        }
                        createPathCoin(lanes[currentLane], groundHeight, -100 - (i * 5), goldMaterial);
                    }
                    
                    // 在没有金币的跑道上放置障碍物
                    for (let i = 0; i < 3; i++) {
                        if (i !== currentLane) {
                            // 创建栅栏柱子
                            const fenceGroup = new THREE.Group();
                            fenceGroup.position.z = -100 - (zigzagCoinCount * 5) + 10;
                            fenceGroup.userData = { type: 'fence' };
                            
                            const postGeometry = new THREE.BoxGeometry(0.15, 1.5, 0.15);
                            const postMaterial = new THREE.MeshStandardMaterial({ 
                                color: 0x8B4513,
                                roughness: 0.8,
                                metalness: 0.1
                            });
                            
                            const post1 = new THREE.Mesh(postGeometry, postMaterial);
                            post1.position.set(lanes[i] - 0.3, 0.75, 0);
                            
                            const post2 = new THREE.Mesh(postGeometry, postMaterial);
                            post2.position.set(lanes[i] + 0.3, 0.75, 0);
                            
                            const railGeometry = new THREE.BoxGeometry(0.8, 0.12, 0.1);
                            const railMaterial = new THREE.MeshStandardMaterial({ 
                                color: 0xA0522D,
                                roughness: 0.8,
                                metalness: 0.1
                            });
                            
                            const rail1 = new THREE.Mesh(railGeometry, railMaterial);
                            rail1.position.set(lanes[i], 0.4, 0);
                            
                            const rail2 = new THREE.Mesh(railGeometry, railMaterial);
                            rail2.position.set(lanes[i], 0.7, 0);
                            
                            const rail3 = new THREE.Mesh(railGeometry, railMaterial);
                            rail3.position.set(lanes[i], 1.0, 0);
                            
                            fenceGroup.add(post1);
                            fenceGroup.add(post2);
                            fenceGroup.add(rail1);
                            fenceGroup.add(rail2);
                            fenceGroup.add(rail3);
                            
                            scene.add(fenceGroup);
                            obstacles.push(fenceGroup);
                        }
                    }
                    break;
                    
                case 3: // 障碍物上方的金币路径
                    // 创建矮墙
                    const wallCount = 3;
                    for (let i = 0; i < wallCount; i++) {
                        const wall = new THREE.Group();
                        wall.position.z = -100 - (i * 20);
                        wall.position.x = lanes[laneIndex];
                        wall.userData = { type: 'low' };
                        
                        const wallMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(1.5, 1.2, 3),
                            new THREE.MeshStandardMaterial({ color: 0x808080 })
                        );
                        wallMesh.position.y = 0.6;
                        wall.add(wallMesh);
                        
                        scene.add(wall);
                        obstacles.push(wall);
                        
                        // 在矮墙上方添加金币
                        for (let j = 0; j < 3; j++) {
                            createPathCoin(lanes[laneIndex], 1.9, -100 - (i * 20) - (j-1) * 1, goldMaterial);
                        }
                    }
                    
                    // 在障碍物之间添加地面金币
                    for (let i = 0; i < wallCount-1; i++) {
                        for (let j = 0; j < 3; j++) {
                            createPathCoin(lanes[laneIndex], groundHeight, -100 - (i * 20) - 10 - (j * 3), goldMaterial);
                        }
                    }
                    break;
                    
                case 4: // 下蹲路径 - 设计更合理
                    // 先放置一系列金币引导玩家进入跑道
                    for (let i = 0; i < 3; i++) {
                        createPathCoin(lanes[laneIndex], groundHeight, -100 - (i * 5), goldMaterial);
                    }
                    
                    // 放置激光障碍物
                    const laserGroup = new THREE.Group();
                    laserGroup.position.z = -100 - 15;
                    laserGroup.userData = { 
                        type: 'ceiling',
                        pulseTime: 0
                    };
                    
                    // ... existing laser creation code ...
                    
                    const pillarGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.1, 8);
                    const pillarMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x333333,
                        roughness: 0.3,
                        metalness: 0.8
                    });
                    
                    const leftPillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                    leftPillar.position.set(lanes[laneIndex] - 1.4, 0.55, 0);
                    
                    const rightPillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                    rightPillar.position.set(lanes[laneIndex] + 1.4, 0.55, 0);
                    
                    const laserGeometry = new THREE.BoxGeometry(3, 0.05, 0.05);
                    const laserMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xff0000,
                        emissive: 0xff0000,
                        emissiveIntensity: 1,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const laser = new THREE.Mesh(laserGeometry, laserMaterial);
                    laser.position.set(lanes[laneIndex], 1.1, 0);
                    
                    const laserLight = new THREE.PointLight(0xff0000, 0.5, 3);
                    laserLight.position.set(0, 0, 0);
                    laser.add(laserLight);
                    
                    // ... existing laser effect code ...
                    
                    laserGroup.add(leftPillar);
                    laserGroup.add(rightPillar);
                    laserGroup.add(laser);
                    
                    scene.add(laserGroup);
                    obstacles.push(laserGroup);
                    
                    // 在激光下方放置金币，提示下蹲
                    for (let i = 0; i < 3; i++) {
                        // 金币稍微低一点，清晰表示需要下蹲
                        createPathCoin(lanes[laneIndex], groundHeight, -100 - 15 - (i * 3), goldMaterial);
                    }
                    
                    // 在激光后面继续放置地面金币
                    for (let i = 0; i < 3; i++) {
                        createPathCoin(lanes[laneIndex], groundHeight, -100 - 30 - (i * 5), goldMaterial);
                    }
                    break;
                    
                case 5: // 混合路径 - 地铁跑酷风格
                    // 创建一系列障碍物和金币的组合
                    
                    // 1. 开始部分 - 地面金币
                    for (let i = 0; i < 3; i++) {
                        createPathCoin(lanes[laneIndex], groundHeight, -100 - (i * 5), goldMaterial);
                    }
                    
                    // 2. 第一个障碍 - 需要跳跃的矮墙
                    const wall1 = new THREE.Mesh(
                        new THREE.BoxGeometry(1.5, 1.0, 1.0),
                        new THREE.MeshStandardMaterial({ color: 0x808080 })
                    );
                    wall1.position.set(lanes[laneIndex], 0.5, -100 - 20);
                    wall1.userData = { type: 'low' };
                    scene.add(wall1);
                    obstacles.push(wall1);
                    
                    // 在矮墙上方添加金币
                    createPathCoin(lanes[laneIndex], 1.6, -100 - 20, goldMaterial);
                    
                    // 3. 中间部分 - 地面金币引导到下一个障碍
                    for (let i = 0; i < 3; i++) {
                        createPathCoin(lanes[laneIndex], groundHeight, -100 - 30 - (i * 5), goldMaterial);
                    }
                    
                    // 4. 第二个障碍 - 栅栏，需要跳过
                    const fence = new THREE.Group();
                    fence.position.set(lanes[laneIndex], 0, -100 - 50);
                    fence.userData = { type: 'fence', lane: lanes[laneIndex] };
                    
                    const postGeometry = new THREE.BoxGeometry(0.15, 1.5, 0.15);
                    const postMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x8B4513,
                        roughness: 0.8,
                        metalness: 0.1
                    });
                    
                    const post1 = new THREE.Mesh(postGeometry, postMaterial);
                    post1.position.set(-0.4, 0.75, 0);
                    
                    const post2 = new THREE.Mesh(postGeometry, postMaterial);
                    post2.position.set(0.4, 0.75, 0);
                    
                    const railGeometry = new THREE.BoxGeometry(1.0, 0.12, 0.1);
                    const railMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xA0522D,
                        roughness: 0.8,
                        metalness: 0.1
                    });
                    
                    const rail = new THREE.Mesh(railGeometry, railMaterial);
                    rail.position.set(0, 1.4, 0);
                    
                    fence.add(post1);
                    fence.add(post2);
                    fence.add(rail);
                    
                    scene.add(fence);
                    obstacles.push(fence);
                    
                    // 在栅栏上方添加金币，略高于栅栏
                    createPathCoin(lanes[laneIndex], 1.9, -100 - 50, goldMaterial);
                    
                    // 5. 结束部分 - 回到地面的金币
                    for (let i = 0; i < 3; i++) {
                        createPathCoin(lanes[laneIndex], groundHeight, -100 - 60 - (i * 5), goldMaterial);
                    }
                    break;
            }
            
            // 记录障碍物生成时间
            lastObstacleTime = Date.now();
        }
        
        // 辅助函数：创建路径中的单个金币
        function createPathCoin(x, y, z, material) {
            // 创建硬币群组
            const coinGroup = new THREE.Group();
            coinGroup.position.set(x, y, z);
            coinGroup.userData = { 
                type: 'coin',
                collected: false // 添加标记防止重复收集
            };
            
            // 主硬币
            const geometry = new THREE.CylinderGeometry(0.4, 0.4, 0.05, 32);
            const obstacle = new THREE.Mesh(geometry, material);
            obstacle.rotation.x = Math.PI / 2; // 硬币平放
            
            // 添加硬币边缘的装饰纹理
            const edgeGeometry = new THREE.TorusGeometry(0.4, 0.05, 8, 32);
            const edge = new THREE.Mesh(edgeGeometry, material);
            edge.rotation.x = Math.PI / 2;
            
            // 添加硬币正面图案
            const starGeometry = new THREE.CircleGeometry(0.25, 5);
            const starMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffd700,
                metalness: 1,
                roughness: 0.1,
                emissive: 0xFFD700,
                emissiveIntensity: 0.4
            });
            
            const star = new THREE.Mesh(starGeometry, starMaterial);
            star.position.z = 0.03;
            star.rotation.z = Math.PI / 5;
            
            obstacle.add(edge);
            obstacle.add(star);
            
            // 添加金币发光效果
            const coinLight = new THREE.PointLight(0xFFD700, 0.5, 2);
            coinLight.position.set(0, 0, 0);
            obstacle.add(coinLight);
            
            // 添加金币悬浮动画
            coinGroup.userData.hoverAnimation = {
                originalY: y,
                offset: Math.random() * Math.PI * 2
            };
            
            coinGroup.add(obstacle);
            coinGroup.userData.rotationSpeed = 0.03;
            
            scene.add(coinGroup);
            obstacles.push(coinGroup);
            
            return coinGroup;
        }
        
        // 窗口调整大小
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 键盘控制
        function onKeyDown(event) {
            if (!gameRunning) return;
            
            switch(event.key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    if (currentLane > 0) currentLane--;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (currentLane < 2) currentLane++;
                    break;
                case ' ':
                case 'Spacebar': // 增加对Spacebar的支持
                case 'w':
                case 'W':
                case 'ArrowUp': // 增加上键跳跃
                    if (canJump && !crouching) { // 下蹲时不能跳跃
                        if (!jumping) {
                            jump();
                        } else if (!doubleJumping) {
                            // 二段跳
                            doubleJump();
                        }
                    }
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    if (!jumping) { // 跳跃时不能下蹲
                        crouch();
                    }
                    break;
            }
        }
        
        // 添加键盘释放事件，用于停止下蹲
        document.addEventListener('keyup', function(event) {
            if (!gameRunning) return;
            
            if (event.key === 'ArrowDown' || event.key === 's' || event.key === 'S') {
                uncrouch();
            }
        });
        
        // 下蹲函数
        function crouch() {
            if (crouching) return;
            
            crouching = true;
            
            // 调整玩家模型
            if (player.children[0]) { // 身体
                player.children[0].scale.y = 0.5; // 降低身体高度
                player.children[0].position.y = 0.3; // 调整身体位置
            }
            
            if (player.children[1]) { // 头部
                player.children[1].position.y = 0.6; // 降低头部位置
            }
            
            // 整体降低玩家位置
            player.position.y = 0.5;
        }
        
        // 站起函数
        function uncrouch() {
            if (!crouching) return;
            
            // 如果有天花板在头上，不能站起
            if (checkCeilingCollision()) {
                return;
            }
            
            crouching = false;
            
            // 恢复玩家模型
            if (player.children[0]) { // 身体
                player.children[0].scale.y = 1;
                player.children[0].position.y = 0.6;
            }
            
            if (player.children[1]) { // 头部
                player.children[1].position.y = player.userData.headPosY;
            }
            
            // 恢复玩家位置
            player.position.y = player.userData.normalHeight;
        }
        
        // 检查是否有天花板障碍物在头上
        function checkCeilingCollision() {
            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                if (obstacle.userData.type === 'ceiling') {
                    // 检查是否在同一跑道
                    if (Math.abs(obstacle.position.x - player.position.x) < 2.5) {
                        // 检查是否在头上
                        if (Math.abs(obstacle.position.z - player.position.z) < 1.5) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        // 跳跃
        function jump() {
            if (!canJump) return;
            
            jumping = true;
            canJump = false; // 暂时禁用跳跃
            const jumpHeight = 4.0; // 保持跳跃高度
            
            // 重置跳跃状态的计时器
            setTimeout(() => {
                canJump = true; // 允许再次跳跃（包括二段跳）
            }, 100); // 更快的跳跃冷却时间，提高操作自由度
            
            // 添加角色跳跃特效
            addJumpEffect();
            
            // 直接使用动画而不是Tween库
            let jumpVelocity = 0.28; // 保持初始跳跃速度
            let gravity = 0.008; // 保持重力加速度
            let jumpTimerId = null;
            
            // 保存跳跃轨迹数据，供金币路径参考
            window.jumpTrajectory = {
                initialVelocity: jumpVelocity,
                gravity: gravity,
                maxHeight: jumpHeight,
                currentVelocity: jumpVelocity // 添加当前速度追踪
            };
            
            const jumpInterval = setInterval(() => {
                if (jumpVelocity > -0.28) { // 还没有落回原位
                    player.position.y += jumpVelocity;
                    jumpVelocity -= gravity; // 减少速度，模拟重力
                    
                    // 更新当前速度，用于碰撞检测
                    window.jumpTrajectory.currentVelocity = jumpVelocity;
                    
                    // 添加身体倾斜效果，模拟跳跃姿态
                    if (player.children[0]) { // 身体
                        // 根据上升/下落调整倾斜角度
                        const tiltAmount = jumpVelocity * 0.2;
                        player.children[0].rotation.x = -tiltAmount;
                    }
                } else {
                    // 到达地面，停止跳跃
                    if (player.position.y <= 0.8) {
                        player.position.y = 0.8; // 确保落到正确位置
                        jumping = false;
                        doubleJumping = false; // 重置二段跳状态
                        // 重置身体倾斜
                        if (player.children[0]) {
                            player.children[0].rotation.x = 0;
                        }
                        clearInterval(jumpInterval);
                        if (jumpTimerId) {
                            clearTimeout(jumpTimerId);
                        }
                    }
                }
            }, 16); // 约60fps
            
            // 安全措施：如果2.5秒后仍未落地，强制重置跳跃状态
            jumpTimerId = setTimeout(() => {
                if (jumping) {
                    jumping = false;
                    doubleJumping = false;
                    player.position.y = 0.8;
                    // 重置身体倾斜
                    if (player.children[0]) {
                        player.children[0].rotation.x = 0;
                    }
                    clearInterval(jumpInterval);
                    console.log("跳跃重置-安全措施触发");
                }
            }, 2500);
        }
        
        // 二段跳
        function doubleJump() {
            if (!jumping || doubleJumping) return;
            
            doubleJumping = true;
            
            // 减小二段跳的高度
            let doubleJumpVelocity = 0.18; // 降低二段跳初始速度
            let gravity = 0.009; // 略微增加二段跳重力加速度，使其下落更快
            
            // 添加角色跳跃特效
            addJumpEffect();
            
            // 更新跳跃轨迹数据，供金币路径参考
            if (window.jumpTrajectory) {
                window.jumpTrajectory.doubleJumpBoost = doubleJumpVelocity;
                window.jumpTrajectory.currentVelocity = doubleJumpVelocity; // 更新当前速度
            }
            
            const jumpInterval = setInterval(() => {
                if (doubleJumpVelocity > -0.28) {
                    player.position.y += doubleJumpVelocity;
                    doubleJumpVelocity -= gravity;
                    
                    // 更新当前速度，用于碰撞检测
                    if (window.jumpTrajectory) {
                        window.jumpTrajectory.currentVelocity = doubleJumpVelocity;
                    }
                    
                    // 添加身体倾斜效果，模拟跳跃姿态
                    if (player.children[0]) { // 身体
                        // 根据上升/下落调整倾斜角度
                        const tiltAmount = doubleJumpVelocity * 0.2;
                        player.children[0].rotation.x = -tiltAmount;
                    }
                } else {
                    // 如果到达地面
                    if (player.position.y <= 0.8) {
                        player.position.y = 0.8;
                        jumping = false;
                        doubleJumping = false;
                        // 重置身体倾斜
                        if (player.children[0]) {
                            player.children[0].rotation.x = 0;
                        }
                        clearInterval(jumpInterval);
                    }
                }
            }, 16);
            
            // 安全措施
            setTimeout(() => {
                if (doubleJumping) {
                    clearInterval(jumpInterval);
                    // 确保重置身体倾斜
                    if (player.children[0]) {
                        player.children[0].rotation.x = 0;
                }
                }
            }, 2000);
        }
        
        // 更新游戏状态
        function update() {
            if (!gameRunning) return;
            
            // 玩家横向移动
            const targetX = lanes[currentLane];
            player.position.x += (targetX - player.position.x) * 0.15; // 加快横向移动速度
            
            // 优化: 只在玩家在视野内时模拟跑步动画
            if (!jumping) {
                const runCycle = Date.now() * 0.01;
                if (player.children[2] && player.children[3]) {
                    player.children[2].position.y = -0.15 + Math.sin(runCycle * 1.5) * 0.1; // 加快腿部动画
                    player.children[3].position.y = -0.15 + Math.sin(runCycle * 1.5 + Math.PI) * 0.1;
                }
            }
            
            // 移动障碍物
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.position.z += speed;
                
                // 优化: 只为在视野范围内的障碍物进行动画更新
                if (obstacle.position.z > -150 && obstacle.position.z < 20) {
                    updateObstacleAnimation(obstacle);
                }
                
                // 对金币进行更大范围的碰撞检测，尤其是在游戏初期
                if (obstacle.userData && obstacle.userData.type === 'coin') {
                    const dx = Math.abs(obstacle.position.x - player.position.x);
                    const dz = Math.abs(obstacle.position.z - player.position.z);
                    
                    // 扩大检测范围，尤其是在游戏初期
                    const checkRange = (obstacle.userData.isInitialCoin || score < 300) ? 2.0 : 1.5;
                    
                    if (dx < checkRange && dz < checkRange && !obstacle.userData.collected) {
                if (checkCollision(obstacle)) {
                            obstacle.userData.collected = true;
                        score += 50;
                        scoreElement.textContent = `分数: ${score}`;
                        scene.remove(obstacle);
                        obstacles.splice(i, 1);
                        
                            createCoinCollectEffect(obstacle.position.clone(), Math.min(10, 15 - Math.floor(obstacles.length / 2)));
                            playCoinSound();
                            continue;
                        }
                    }
                }
                // 常规的障碍物碰撞检测
                else if (obstacle.position.z > -5 && obstacle.position.z < 5) {
                    // 添加简单碰撞预检测，加快排除明显不会碰撞的障碍物
                    const dx = Math.abs(obstacle.position.x - player.position.x);
                    const dz = Math.abs(obstacle.position.z - player.position.z);
                    
                    if (dx < 2.0 && dz < 1.0) { // 只在较近距离进行完整碰撞检测
                if (checkCollision(obstacle)) {
                    if (obstacle.userData && obstacle.userData.type !== 'coin') {
                        console.log("碰撞检测：", obstacle.userData ? obstacle.userData.type : "未知类型", 
                                    "位置:", obstacle.position,
                                    "玩家高度:", player.position.y,
                                    "跳跃状态:", jumping,
                                    "下蹲状态:", crouching);
                        gameOver();
                        break;
                    }
                }
                    }
                }
                
                // 移除已通过的障碍物
                if (obstacle.position.z > 10) {
                    scene.remove(obstacle);
                    obstacles.splice(i, 1);
                    
                    // 如果不是硬币且顺利通过，增加分数
                    if (obstacle.userData && obstacle.userData.type !== 'coin') {
                        score += 10;
                        scoreElement.textContent = `分数: ${score}`;
                    }
                }
            }
            
            // 随机生成新障碍物
            // 优化: 根据分数调整障碍物生成频率，但不会过于密集
            const baseChance = 0.012; // 降低基础生成几率
            const scoreBonus = Math.min(score / 50000, 0.028); // 限制最大分数影响
            const maxChance = 0.04; // 降低最大生成几率
            
            // 使用分数调整生成几率，但有上限
            const obstacleChance = Math.min(baseChance + scoreBonus, maxChance);
            
            // 优化: 根据当前障碍物密度动态调整生成概率
            const densityFactor = Math.max(0.5, 1 - obstacles.length / 10);
            
            if (Math.random() < obstacleChance * densityFactor) {
                createObstacle();
            }
            
            // 移动地面
            ground.position.z += speed;
            if (ground.position.z > 0) {
                ground.position.z = -500;
            }
            
            // 移动背景元素
            updateBackground();
            
            // 随着分数增加游戏难度
            speed = 0.3 + (score / 3000); // 提高基础速度和增长率
            
            // 更新下蹲状态，如果没有天花板障碍物，自动站起
            if (crouching && !checkCeilingCollision() && Math.random() < 0.05) {
                uncrouch();
            }
        }
        
        // 添加障碍物动画更新函数
        function updateObstacleAnimation(obstacle) {
            // 装饰物不参与碰撞检测
            if (obstacle.userData && obstacle.userData.type === 'decoration') {
                return;
            }
            
            // 旋转金币
            if (obstacle.userData && obstacle.userData.type === 'coin') {
                // 如果是金币组，应用特殊效果
                if (obstacle.userData.rotationSpeed) {
                    obstacle.rotation.z += obstacle.userData.rotationSpeed;
                }
            }
            
            // 旋转矮障碍物（岩石）
            if (obstacle.userData && obstacle.userData.type === 'low' && obstacle.userData.rotationSpeed) {
                obstacle.rotation.y += obstacle.userData.rotationSpeed;
            }
            
            // 水晶柱脉冲发光效果
            if (obstacle.userData && obstacle.userData.type === 'high') {
                obstacle.userData.pulseTime = (obstacle.userData.pulseTime || 0) + 0.05;
                
                // 更新发光强度
                const pulseFactor = Math.sin(obstacle.userData.pulseTime) * 0.5 + 0.5;
                if (obstacle.children[0] && obstacle.children[0].isLight) {
                    obstacle.children[0].intensity = 0.5 + pulseFactor;
                }
                
                // 更新材质颜色
                if (obstacle.material) {
                    const hue = (0.5 + pulseFactor * 0.1) % 1;
                    obstacle.material.color.setHSL(hue, 0.8, 0.5);
                    obstacle.material.emissive.setHSL(hue, 0.8, 0.2);
                }
            }
            
            // 更新能量球组
            if (obstacle.userData && obstacle.userData.type === 'energy') {
                obstacle.rotation.y += obstacle.userData.rotationSpeed;
                
                // 更新每个能量球
                obstacle.children.forEach(sphere => {
                    // 浮动动画
                    if (sphere.userData && sphere.userData.originalY) {
                        sphere.position.y = sphere.userData.originalY + Math.sin(Date.now() * 0.002 + sphere.userData.floatOffset) * 0.2;
                        
                        // 旋转环
                        if (sphere.children.length >= 3) {
                            sphere.children[1].rotation.z += sphere.userData.ringRotation;
                            sphere.children[2].rotation.x += sphere.userData.ringRotation * 0.7;
                        }
                    }
                });
            }
            
            // 激光障碍物的闪烁效果
            if (obstacle.userData && obstacle.userData.type === 'ceiling') {
                obstacle.userData.pulseTime = (obstacle.userData.pulseTime || 0) + 0.1;
                
                // 如果是激光组
                if (obstacle.children && obstacle.children.length > 0) {
                    // 查找激光部分（通常是第三个子元素）
                    const laser = obstacle.children[2];
                    if (laser && laser.material) {
                        const pulseFactor = Math.sin(obstacle.userData.pulseTime) * 0.3 + 0.7;
                        laser.material.opacity = pulseFactor;
                        
                        // 更新光源强度
                        if (laser.children[0] && laser.children[0].isLight) {
                            laser.children[0].intensity = pulseFactor;
                        }
                    }
                    
                    // 更新警示灯（在支柱中）
                    const leftPillar = obstacle.children[0];
                    const rightPillar = obstacle.children[1];
                    if (leftPillar && leftPillar.children[0]) {
                        const warningPulse = Math.sin(obstacle.userData.pulseTime * 2) > 0 ? 1 : 0.2;
                        leftPillar.children[0].material.emissiveIntensity = warningPulse;
                        rightPillar.children[0].material.emissiveIntensity = warningPulse;
                    }
                }
            }
            
            // 旋转金币，对于在地面的金币，添加轻微悬浮动画
            if (obstacle.userData && obstacle.userData.type === 'coin') {
                // 旋转效果
                if (obstacle.userData.rotationSpeed) {
                    obstacle.rotation.z += obstacle.userData.rotationSpeed;
                }
                
                // 仅对地面上的金币添加悬浮效果
                if (obstacle.userData.hoverAnimation && obstacle.userData.hoverAnimation.originalY <= 0.7) {
                    const time = Date.now() * 0.002 + obstacle.userData.hoverAnimation.offset;
                    const hoverHeight = Math.sin(time) * 0.1;
                    obstacle.position.y = obstacle.userData.hoverAnimation.originalY + hoverHeight;
                }
            }
        }
        
        // 更新背景元素
        function updateBackground() {
            // 移动山脉
            const mountainSpeed = speed * 0.2; // 山脉移动速度比玩家慢
            mountains.forEach(mountain => {
                mountain.position.z += mountainSpeed;
                if (mountain.position.z > 50) {
                    mountain.position.z = -300;
                    // 修改山脉的重置位置
                    const side = Math.random() > 0.5 ? 1 : -1;
                    const distance = 25 + Math.random() * 90;
                    mountain.position.x = side * distance;
                    mountain.position.y = -20; // 确保y坐标保持一致
                }
            });
            
            // 移动云朵
            const cloudSpeed = speed * 0.3;
            clouds.forEach(cloud => {
                cloud.position.z += cloudSpeed;
                if (cloud.position.z > 50) {
                    cloud.position.z = -500;
                    cloud.position.x = Math.random() * 200 - 100;
                    cloud.position.y = Math.random() * 50 + 50;
                }
            });
            
            // 移动星星
            const starSpeed = speed * 0.1;
            stars.forEach(star => {
                star.position.z += starSpeed;
                if (star.position.z > 50) {
                    star.position.z = -300;
                    star.position.x = Math.random() * 400 - 200;
                    star.position.y = Math.random() * 200 + 50;
                }
            });
        }
        
        // 检查碰撞
        function checkCollision(obstacle) {
            // 1. 首先修复横向距离检测
            // 优化: 如果障碍物是装饰物或明显不在碰撞范围内，跳过检测
            if (!obstacle.userData || obstacle.userData.type === 'decoration') {
                return false;
            }
            
            // 横向距离检测 - 根据跑道位置而不是直接距离
            const obstacleTrack = Math.round((obstacle.position.x + 2) / 2); // 将x坐标转换为跑道索引(0,1,2)
            const playerTrack = currentLane; // 玩家当前跑道索引
            
            // 2. 特殊处理激光类型障碍物 (ceiling)，因为它们横跨多个跑道
            if (obstacle.userData.type === 'ceiling') {
                // 判断激光横向范围
                const isInLaserRange = Math.abs(obstacle.position.x - player.position.x) < 1.5;
                
                // 只有在玩家确实在激光跑道附近，才检查高度碰撞
                if (isInLaserRange && Math.abs(obstacle.position.z - player.position.z) < 0.9) {
                    // 只有在站立状态下才检查天花板碰撞
                    if (!crouching) {
                        const headY = player.position.y + 1.1; // 玩家头部高度
                        const laserY = obstacle.position.y + (obstacle.children[2] ? obstacle.children[2].position.y : 1.1); // 激光高度
                        return headY > laserY; // 只有当头部高于激光高度时才碰撞
                    }
                }
                return false;
            }
            
            // 3. 处理正常跑道类障碍物，必须是同一跑道才可能碰撞
            // 检查是否在同一跑道
            if (obstacleTrack !== playerTrack && obstacle.userData.type !== 'energy') {
                // 例外：栅栏可能覆盖多个跑道
                if (obstacle.userData.type === 'fence') {
                    // 检查玩家是否在栅栏所在的跑道
                    if (obstacle.userData && obstacle.userData.lane !== undefined) {
                        const fenceLane = Math.round((obstacle.userData.lane + 2) / 2);
                        if (fenceLane !== playerTrack) {
                            return false; // 不在栅栏所在跑道
                        }
                    } else {
                        return false; // 没有跑道信息，不可能碰撞
                    }
                } else {
                    return false; // 不在同一跑道，不可能碰撞
                }
            }
            
            // 4. 纵向距离检测优化
            // 纵向距离过大，不考虑碰撞
            if (Math.abs(obstacle.position.z - player.position.z) > 1.0) { // 减小检测距离
                return false;
            }
            
            // 5. 特殊处理每种障碍物类型的碰撞逻辑
            
            // 金币碰撞检测保持不变
            if (obstacle.userData && obstacle.userData.type === 'coin') {
                const dx = Math.abs(obstacle.position.x - player.position.x);
                const dy = Math.abs(obstacle.position.y - player.position.y);
                const dz = Math.abs(obstacle.position.z - player.position.z);
                
                if (obstacle.userData.isInitialCoin || score < 300) {
                    return dx < 1.5 && dy < 1.5 && dz < 1.0;
                } else {
                    return dx < 1.2 && dy < 1.4 && dz < 0.9;
                }
            }
            
            // 其他障碍物类型的检测
            if (['low', 'high', 'fence'].includes(obstacle.userData.type)) {
                const dx = Math.abs(obstacle.position.x - player.position.x);
                const dz = Math.abs(obstacle.position.z - player.position.z);
                
                const type = obstacle.userData.type;
                
                if (type === 'low') {
                    // 跳跃状态下不会碰到低矮障碍物
                    if (player.position.y > 1.0) return false;
                    return dx < 0.6 && dz < 0.5;
                }
                
                if (type === 'high') {
                    // 下蹲状态下不会碰到高障碍物
                    if (crouching) return false;
                    
                    const playerBottom = player.position.y - 0.6;
                    const obstacleTop = obstacle.position.y + 1.0;
                    
                    if (playerBottom > obstacleTop) {
                        return false;
                    }
                    
                    if (jumping && window.jumpTrajectory && window.jumpTrajectory.currentVelocity > 0.1) {
                        return dx < 0.5 && dz < 0.4;
                    }
                    
                    return dx < 0.6 && dz < 0.5;
                }
                
                if (type === 'fence') {
                    // 再次确认玩家是否在栅栏所在的跑道
                    if (Math.abs(obstacle.position.z - player.position.z) < 0.7) {
                        if (crouching) {
                            return false;
                        }
                        
                        const playerBottom = player.position.y - 0.6;
                        const fenceTop = 1.5;
                        
                        if (playerBottom > fenceTop) {
                            return false;
                        }
                        
                        return true;
                    }
                    return false;
                }
            }
            
            // 能量球类型的碰撞逻辑保持不变
            if (obstacle.userData.type === 'energy') {
                let collision = false;
                obstacle.children.forEach(sphere => {
                    if (sphere.userData && !collision) {
                        const dx = Math.abs(sphere.position.x + obstacle.position.x - player.position.x);
                        const dy = Math.abs(sphere.position.y + obstacle.position.y - player.position.y);
                        const dz = Math.abs(sphere.position.z + obstacle.position.z - player.position.z);
                        
                        if (player.position.y > (sphere.position.y + obstacle.position.y + 0.8)) {
                            return;
                        }
                        
                        if (dx < 0.5 && dy < 0.5 && dz < 0.5) {
                            collision = true;
                        }
                    }
                });
                return collision;
            }
            
            // 最后使用通用碰撞检测，但使检测范围更加精确
            if (Math.abs(obstacle.position.z - player.position.z) < 0.6 &&
                Math.abs(obstacle.position.x - player.position.x) < 0.8) {
                const playerBox = new THREE.Box3().setFromObject(player);
                playerBox.min.add(new THREE.Vector3(0.2, 0.1, 0.2)); // 增加缩小幅度
                playerBox.max.sub(new THREE.Vector3(0.2, 0.1, 0.2)); 
                
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                obstacleBox.min.add(new THREE.Vector3(0.2, 0.1, 0.2));
                obstacleBox.max.sub(new THREE.Vector3(0.2, 0.1, 0.2));
                
                // 添加调试信息
                if (Math.random() < 0.01) { // 1%概率输出调试信息
                    console.log("碰撞盒检测:", 
                                "玩家跑道:", playerTrack,
                                "障碍物跑道:", obstacleTrack,
                                "碰撞结果:", playerBox.intersectsBox(obstacleBox));
                }
                
                return playerBox.intersectsBox(obstacleBox);
            }
            
            return false;
        }
        
        // 游戏结束
        function gameOver() {
            gameRunning = false;
            finalScoreElement.textContent = `最终分数: ${score}`;
            gameOverElement.style.display = 'block';
        }
        
        // 重置游戏
        function resetGame() {
            // 清除障碍物
            obstacles.forEach(obstacle => {
                scene.remove(obstacle);
            });
            obstacles = [];
            
            // 重置玩家位置
            player.position.set(0, 0.8, 0);
            currentLane = 1;
            jumping = false;
            doubleJumping = false;
            
            // 重置分数和速度
            score = 0;
            speed = 0.3;
            scoreElement.textContent = `分数: ${score}`;
            
            // 隐藏游戏结束界面
            gameOverElement.style.display = 'none';
            
            // 重启游戏
            gameRunning = true;
            
            // 重置下蹲状态
            if (crouching) {
                uncrouch();
            }
            crouching = false;
            
            // 重置障碍物生成间隔
            obstacleMinDistance = 50;
            lastObstacleTime = 0;
            
            // 确保生成适合初始玩家的金币路径
            setTimeout(() => {
                if (gameRunning && obstacles.length < 5) {
                    createInitialCoins(1); // 在中间跑道生成金币
                }
            }, 1000);
        }
        
        // 开始游戏
        function startGame() {
            startScreen.style.display = 'none';
            resetGame();
            
            // 启动玩家进度检查系统
            setTimeout(checkPlayerProgress, 2000);
            
            // 游戏开始时显示提示
            const jumpTipElement = document.createElement('div');
            jumpTipElement.style.position = 'absolute';
            jumpTipElement.style.top = '50px';
            jumpTipElement.style.left = '50%';
            jumpTipElement.style.transform = 'translateX(-50%)';
            jumpTipElement.style.color = 'white';
            jumpTipElement.style.backgroundColor = 'rgba(0,0,0,0.7)';
            jumpTipElement.style.padding = '10px 20px';
            jumpTipElement.style.borderRadius = '20px';
            jumpTipElement.style.zIndex = '100';
            jumpTipElement.innerHTML = '连续按跳跃键可以二段跳！';
            document.getElementById('gameContainer').appendChild(jumpTipElement);
            
            setTimeout(() => {
                jumpTipElement.style.opacity = '0';
                jumpTipElement.style.transition = 'opacity 1s';
                setTimeout(() => {
                    document.getElementById('gameContainer').removeChild(jumpTipElement);
                }, 1000);
            }, 3000);
        }
        
        // 添加触摸控制
        function addTouchControls() {
            // 左侧触摸 = 左移
            // 右侧触摸 = 右移
            // 上滑 = 跳跃
            // 下滑 = 下蹲
            document.addEventListener('touchstart', function(event) {
                if (!gameRunning) return;
                
                const touch = event.touches[0];
                const screenWidth = window.innerWidth;
                
                if (touch.clientX < screenWidth / 3) {
                    // 触摸屏幕左侧
                    if (currentLane > 0) currentLane--;
                } else if (touch.clientX > screenWidth * 2 / 3) {
                    // 触摸屏幕右侧
                    if (currentLane < 2) currentLane++;
                } else {
                    // 触摸屏幕中间进行跳跃
                    if (canJump && !crouching) {
                        if (!jumping) {
                            jump();
                        } else if (!doubleJumping) {
                            // 二段跳
                            doubleJump();
                        }
                    }
                }
            });
            
            // 添加滑动手势
            let startY, startX;
            document.addEventListener('touchstart', function(event) {
                startY = event.touches[0].clientY;
                startX = event.touches[0].clientX;
            });
            
            document.addEventListener('touchend', function(event) {
                if (!gameRunning) return;
                
                const endY = event.changedTouches[0].clientY;
                const endX = event.changedTouches[0].clientX;
                
                // 垂直滑动距离大于水平滑动
                if (Math.abs(endY - startY) > Math.abs(endX - startX)) {
                if (startY && startY - endY > 50) { // 上滑超过50px
                        if (canJump && !crouching) {
                        if (!jumping) {
                            jump();
                        } else if (!doubleJumping) {
                            // 二段跳
                            doubleJump();
                            }
                        }
                    } else if (startY && endY - startY > 50) { // 下滑超过50px
                        if (!jumping) {
                            crouch();
                            
                            // 添加延时自动站起，延长0.3秒
                            setTimeout(uncrouch, 1100); // 从原来的800ms改为1100ms
                        }
                    }
                }
            });
        }
        
        // 创建硬币收集特效
        function createCoinCollectEffect(position, particleCount = 15) {
            // 优化: 减少粒子数量，提高性能
            const particles = [];
            
            // 创建金色粒子
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 4, 4); // 降低几何体复杂度
                const material = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
                const particle = new THREE.Mesh(geometry, material);
                
                // 设置粒子初始位置
                particle.position.copy(position);
                
                // 设置随机速度方向
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    Math.random() * 0.2,
                    (Math.random() - 0.5) * 0.2
                );
                
                scene.add(particle);
                particles.push(particle);
                
                // 设置粒子生命周期
                setTimeout(() => {
                    scene.remove(particle);
                    const index = particles.indexOf(particle);
                    if (index > -1) {
                        particles.splice(index, 1);
                    }
                }, 800); // 缩短生命周期
            }
            
            // 更新粒子位置
            const updateParticles = function() {
                if (particles.length === 0) return;
                
                for (let i = 0; i < particles.length; i++) {
                    particles[i].position.add(particles[i].velocity);
                    particles[i].velocity.y -= 0.01; // 添加重力
                    particles[i].scale.multiplyScalar(0.96); // 粒子逐渐缩小
                }
                
                // 优化: 只在仍有粒子存在时继续更新
                if (particles.length > 0) {
                requestAnimationFrame(updateParticles);
                }
            };
            
            updateParticles();
        }
        
        // 辅助函数：根据索引获取障碍物类型
        function getObstacleTypeByIndex(index) {
            const types = ['low', 'high', 'fence', 'energy', 'coin', 'ceiling'];
            return types[index];
        }
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            // 调试信息
            if (Math.random() < 0.005) {
                console.log("跳跃状态: " + jumping + ", 玩家高度: " + player.position.y);
            }
            
            update();
            renderer.render(scene, camera);
        }
        
        // 事件监听
        restartBtn.addEventListener('click', resetGame);
        startBtn.addEventListener('click', startGame);
        
        // 初始化并开始动画
        init();
        animate();
        
        // 添加跳跃特效
        function addJumpEffect() {
            // 创建跳跃尘埃效果
            const particleCount = 5;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 4, 4);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xCCCCCC,
                    transparent: true,
                    opacity: 0.7
                });
                const particle = new THREE.Mesh(geometry, material);
                
                // 设置粒子初始位置在玩家脚下
                particle.position.set(
                    player.position.x + (Math.random() - 0.5) * 0.5,
                    0.2,
                    player.position.z + (Math.random() - 0.5) * 0.5
                );
                
                // 设置随机速度方向（主要是向外扩散）
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    Math.random() * 0.05,
                    (Math.random() - 0.5) * 0.1
                );
                
                scene.add(particle);
                particles.push(particle);
                
                // 设置粒子生命周期
                setTimeout(() => {
                    scene.remove(particle);
                    const index = particles.indexOf(particle);
                    if (index > -1) {
                        particles.splice(index, 1);
                    }
                }, 300);
            }
            
            // 更新粒子位置
            const updateParticles = function() {
                if (particles.length === 0) return;
                
                for (let i = 0; i < particles.length; i++) {
                    particles[i].position.add(particles[i].velocity);
                    particles[i].scale.multiplyScalar(0.95);
                    particles[i].material.opacity -= 0.02;
                }
                
                if (particles.length > 0) {
                    requestAnimationFrame(updateParticles);
                }
            };
            
            updateParticles();
        }
        
        // 添加收集金币时的音效
        function playCoinSound() {
            // 使用Web Audio API创建简单的音效
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(880, audioContext.currentTime); // A5
                oscillator.frequency.exponentialRampToValueAtTime(1760, audioContext.currentTime + 0.1); // A6
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.2);
            } catch (e) {
                console.log("音效播放失败:", e);
            }
        }
        
        // 添加专门为游戏开始设计的简单金币路径
        function createInitialCoins(laneIndex) {
            // 创建一条直线金币，确保玩家容易收集到
            const goldMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700, 
                metalness: 1,
                roughness: 0.3,
                emissive: 0xFFD700,
                emissiveIntensity: 0.3 // 增加亮度使其更明显
            });
            
            const coinCount = 5;
            for (let i = 0; i < coinCount; i++) {
                // 创建地面上的金币，而不是浮空
                const coin = createPathCoin(lanes[laneIndex], 0.5, -100 - (i * 8), goldMaterial);
                // 增加碰撞范围
                coin.userData.isInitialCoin = true;
            }
            
            // 记录障碍物生成时间
            lastObstacleTime = Date.now();
        }
        
        // 新玩家辅助系统 - 确保新手玩家能收集到足够金币
        function checkPlayerProgress() {
            if (gameRunning && score < 200 && obstacles.length < 8 && Math.random() < 0.3) {
                // 玩家分数低且场景中障碍物较少时，增加金币生成概率
                createInitialCoins(currentLane); // 在当前跑道生成金币
            }
            
            // 每2秒检查一次
            setTimeout(checkPlayerProgress, 2000);
        }
    </script>
</body>
</html> 